Different approach:
Copy entire blocks.
Upon detecting block, copy to new memory block pool.

Hmm, could directly patch like in valgrind.
My approach makes indirect jumps faster -- don't have to do translation.

What to do when new block b is discovered:
1. Allocate b' in code pool.
2. Set breakpoint at end. Upon reaching breakpoint, code will then patch the next block.

Whenever a breakpoint is reached, find next


COMPONENTS:
[ ] Block class.
[ ] Set of blocks holding original code.


;;;;;;

Preserve origianl code.
Completely rewrite.
Translate orig block addresses to rewritten block addresses.
Jump directly there.

DIRECT, UNCONDITONAL JUMPS: Easy. Just jump to next rewritten block. This includes CALLs!
DIRECT, CONDITONAL JUMPS: Use conditional jump to next rewritten block. Then either (1) BKPT or (2) unconditional jump to fallthrough block.
INDIRECT JUMPS: bkpt for now to translate into rewritten block address. This includes CALLs and RETs!


HMM..
Don't overuse classes. Makes problem even harder.

[ ] Map from orig addresses to blocks.

---------------

Simplify block instructions by putting it into one instruction stream.
Observation: Only one breakpoint will be active at once. For direct branches, the direct branch breakpoint will be hit exactly once.

Improvement:
Don't patch positive conditional jumps unless branch is actually taken, direct or indirect.
Currently, the tool patches direct jumps eagerly, but this isn't always correct.

----------

Block Terminator Instruction Stages:

Block creation:
- Fix up call.
- Branch to BKPT.
- Fallthrough is BKPT.

Hmm... Could have terminator be other class with virtual methods... try this.

Hmmm
How the hell to create relocatable instructions?
Just save data, xedd,

----

Problem: RIP-relative memory jumps are difficult.
Solution: just jump to original address then single-step instruction.
	  If call, pop off stack push.
---------

Hmm, instead of transforming ANY indirect branch instructions, can just jump directly to the indirect branch branch instruction for simplicity.

Wait, can just jump to calls, since they (1) never fallthru and (2) it will push the right value onto the stack.