Different approach:
Copy entire blocks.
Upon detecting block, copy to new memory block pool.

Hmm, could directly patch like in valgrind.
My approach makes indirect jumps faster -- don't have to do translation.

What to do when new block b is discovered:
1. Allocate b' in code pool.
2. Set breakpoint at end. Upon reaching breakpoint, code will then patch the next block.

Whenever a breakpoint is reached, find next


COMPONENTS:
[ ] Block class.
[ ] Set of blocks holding original code.


;;;;;;

Preserve origianl code.
Completely rewrite.
Translate orig block addresses to rewritten block addresses.
Jump directly there.

DIRECT, UNCONDITONAL JUMPS: Easy. Just jump to next rewritten block. This includes CALLs!
DIRECT, CONDITONAL JUMPS: Use conditional jump to next rewritten block. Then either (1) BKPT or (2) unconditional jump to fallthrough block.
INDIRECT JUMPS: bkpt for now to translate into rewritten block address. This includes CALLs and RETs!


HMM..
Don't overuse classes. Makes problem even harder.

[ ] Map from orig addresses to blocks.

---------------

Simplify block instructions by putting it into one instruction stream.
Observation: Only one breakpoint will be active at once. For direct branches, the direct branch breakpoint will be hit exactly once.

Improvement:
Don't patch positive conditional jumps unless branch is actually taken, direct or indirect.
Currently, the tool patches direct jumps eagerly, but this isn't always correct.